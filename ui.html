<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    margin: 0;
    padding: 0;
    background-color: #EFEFEF;
    color: #2D2D2D;
    overflow: hidden; 
  }

  /* --- Estrutura Principal --- */
  .plugin-wrapper {
    display: flex;
    flex-direction: column;
    height: 100vh; /* Ocupa toda a altura da janela do plugin */
  }
  
  /* --- 1. Área das Abas --- */
  .tabs-container {
    background-color: #FFFFFF;
    padding: 16px;
    border-bottom: 1px solid #AEAEAE;
    flex-shrink: 0;
  }

  .tabs {
    display: flex;
  }

  .tab {
    font-size: 14px;
    margin-right: 16px;
    cursor: pointer;
    font-weight: 400;
    color: #AEAEAE;
  }

  .tab.active {
    font-weight: 600;
    color: #2D2D2D;
  }
  
  /* --- 2. Área de Conteúdo (Inputs) --- */
  .content-area {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px;
  }

  .container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    color: #5F5F5F;
    height: 100%;
  }
  .container p {
    margin: 0;
  }
  .container p:last-child {
    font-size: 12px;
    margin-top: 4px;
  }

  .text-list {
    width: 100%;
    text-align: left;
  }

  .frame-group {
    margin-bottom: 16px;
  }

  .frame-title {
    font-size: 13px;
    font-weight: 600;
    color: #2D2D2D;
    margin-bottom: 8px;
  }

  .input-wrapper {
    position: relative;
    width: 100%;
    margin-bottom: 8px;
  }

  input[type="text"] {
    width: 100%;
    padding: 12px 12px;
    padding-right: 32px;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    box-sizing: border-box;
    background-color: #FFFFFF;
    transition: border-color 0.2s;

    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 400;
    color: #5F5F5F;
  }
  input[type="text"]:focus {
    outline: none;
    border: 1px solid #2D2D2D;
  }

  .reset-icon {
    position: absolute;
    right: 40px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 16px;
    cursor: pointer;
    transition: opacity 0.1s, visibility 0.2s;
    visibility: hidden;
    color: #5F5F5F;
    opacity: 0.5 ;
  }
  .reset-icon:hover { opacity: 1; }
  .reset-icon.visible { visibility: visible; }

  .footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 20px;
    background-color: #FFFFFF;
    border-top: 0.5px solid #AEAEAE;
    flex-shrink: 0;
  }

  button {
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600; /* Semibold */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
  }

  /* Botão Aplicar */
  button#apply {
    /* Padding para guiar o tamanho */
    padding: 12px 20px;
  }
  
  .arrow {
    margin-left: 8px; /* Espaçamento do texto para a seta */
    transition: color 0.2s;
  }

  /* Estado Ativado do Aplicar */
  button#apply {
    background: #2D2D2D;
    color: #FFFFFF;
  }

  /* Estado Desativado do Aplicar */
  button#apply:disabled {
    background: #DFDFDF;
    color: #5F5F5F;
    cursor: not-allowed;
  }

  .hidden {
    display: none;
  }

  .finder-section { margin-bottom: 16px; }
  .finder-header { display: flex; justify-content: space-between; align-items: center; }
  .finder-title { font-size: 13px; font-weight: 600; color: #2D2D2D; margin-bottom: 4px; }
  .finder-nav { display: flex; align-items: center; gap: 2px; margin-bottom: 1px; }
  .finder-nav span { font-size: 13px; color: #5F5F5F; min-width: 40px; text-align: center; }
  .finder-nav button { background-color: transparent; color: #5F5F5F; padding: 4px 6px; border-radius: 8px; }
  .finder-nav button:disabled { color: #C1C1C1; border-color: #EFEFEF; cursor: not-allowed; }
  .finder-nav button:hover:not(:disabled) { background-color: transparent; }

  .finder-footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 20px 16px; /* antes era apenas 20px */
    background-color: #FFFFFF;
    border-top: 0.5px solid #AEAEAE;
    flex-shrink: 0;
    margin-top: auto;
  }

  .finder-actions {
    display: flex;
    gap: 8px;
  }

  .finder-actions button {
    padding: 12px 20px;
    font-size: 14px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    border-radius: 6px;
    cursor: pointer;
  }
  #replace-single {
    background-color: #FFFFFF;
    color: #2D2D2D;
    border: 1px solid #AEAEAE;
  }

  #replace-all {
    background-color: #2D2D2D;
    color: #FFFFFF;
    border: none;
  }
  .finder-actions button:disabled {
    background: #DFDFDF;
    color: #5F5F5F;
    cursor: not-allowed;
    border-color: transparent;
  }
  #find-input {
    /* Adiciona espaço à direita para o botão não sobrepor o texto */
    padding-right: 40px; 
  }
  #case-sensitive-toggle {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #AEAEAE;
    font-size: 14px;
    line-height: 1;
    font-weight: 700;
  }
  #case-sensitive-toggle:hover {
    background-color: #f0f0f0;
  }
  #case-sensitive-toggle.active {
    background-color: #e0e0e0;
    color: #2D2D2D;
  }

  .feedback-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e0f2fe;
    color: #0c4a6e;
    padding: 8px 12px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 8px;
  }

  .kbd, kbd {
    background-color: #F5F5F5;
    border: 1px solid #CCC;
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 12px;
    font-family: 'Inter', monospace;
    box-shadow: inset 0 -1px 0 #BBB;
    color: #2D2D2D;
    margin: 0 2px;
  }

  #undo-button {
    background: none;
    border: 1px solid #0ea5e9;
    color: #0284c7;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  #undo-button:hover {
    background-color: #f0f9ff;
  }

  #preview-text {
    width: 100%;
    height: 96px;
    resize: none;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    padding: 12px;
    background-color: #F5F5F5;
    color: #5F5F5F;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    box-sizing: border-box;
  }

  .hidden {
    display: none !important;
  }

  .tabs-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  #formatter-toggle {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
    border-radius: 4px;
    margin-left: 16px;
  }
  #formatter-toggle:hover {
    opacity: 1;
    background-color: #f0f0f0;
  }
  #formatter-toggle.active {
    opacity: 1;
    background-color: #e0f2fe; /* Azul claro para indicar regra ativa */
  }

  /* O SVG precisa ter seu stroke alterado para que a cor funcione melhor */
  #formatter-toggle.active svg path {
    stroke: #0c4a6e; /* Azul escuro para contraste */
  }
  #formatter-toggle svg {
    display: block;
    width: 16px;
    height: 16px;
  }

  .formatter-panel {
    position: absolute;
    top: 55px; /* Abaixo da barra de abas */
    right: 16px;
    left: 16px;
    background-color: #FFFFFF;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    padding: 12px;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  .formatter-panel .finder-title {
    margin-bottom: 8px;
  }
  .formatter-tokens {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
  }
  .formatter-tokens .token {
    background-color: #e0e0e0;
    color: #2D2D2D;
    font-size: 12px;
    font-weight: 500;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
  }
  .formatter-panel-footer {
    display: flex;
    justify-content: flex-end;
    margin-top: 12px;
  }
  #clear-format-rule {
    font-size: 12px;
    color: #5F5F5F;
    background: none;
    border: none;
    text-decoration: underline;
    margin-right: 8px;
  }

/* --- Estilos para o Wrapper das Abas --- */
.tabs-wrapper {
  display: flex; /*[cite: 99]*/
  justify-content: space-between; /*[cite: 99]*/
  align-items: center; /*[cite: 99]*/
}

#formatter-toggle {
  background: none; /*[cite: 100]*/
  border: none; /*[cite: 100]*/
  padding: 4px; /*[cite: 100]*/
  cursor: pointer; /*[cite: 100]*/
  opacity: 0.5; /*[cite: 100]*/
  transition: opacity 0.2s, background-color 0.2s; /*[cite: 101]*/
  border-radius: 4px; /*[cite: 101]*/
}
#formatter-toggle:hover {
  opacity: 1; /*[cite: 101]*/
  background-color: #f0f0f0; /*[cite: 101]*/
}
#formatter-toggle.active {
  opacity: 1; /*[cite: 102]*/
  background-color: #e0f2fe; /*[cite: 102]*/
}
#formatter-toggle svg {
  display: block; /*[cite: 103]*/
  width: 16px; /*[cite: 103]*/
  height: 16px; /*[cite: 103]*/
}

/* --- Estilos para o Painel de Formatação --- */
.formatter-panel {
  position: absolute; /*[cite: 104]*/
  top: 55px; /* Abaixo da barra de abas */
  right: 16px; /*[cite: 105]*/
  left: 16px; /*[cite: 105]*/
  background-color: #FFFFFF; /*[cite: 105]*/
  border: 1px solid #AEAEAE; /*[cite: 105]*/
  border-radius: 8px; /*[cite: 106]*/
  padding: 12px; /*[cite: 106]*/
  z-index: 10; /*[cite: 106]*/
  box-shadow: 0 4px 12px rgba(0,0,0,0.1); /*[cite: 106]*/
}
.formatter-panel .finder-title {
  margin-bottom: 8px;
}
.formatter-tokens {
  display: flex; /*[cite: 107]*/
  flex-wrap: wrap; /*[cite: 107]*/
  gap: 8px; /*[cite: 107]*/
  margin-top: 8px; /*[cite: 107]*/
}
.formatter-tokens .token {
  background-color: #e0e0e0; /*[cite: 108]*/
  color: #2D2D2D; /*[cite: 108]*/
  font-size: 12px; /*[cite: 108]*/
  font-weight: 500; /*[cite: 108]*/
  padding: 4px 8px; /*[cite: 108]*/
  border-radius: 4px; /*[cite: 108]*/
  cursor: pointer; /*[cite: 108]*/
}
.formatter-panel-footer {
  display: flex; /*[cite: 109]*/
  justify-content: flex-end; /*[cite: 109]*/
  margin-top: 12px; /*[cite: 109]*/
}
#clear-format-rule {
  font-size: 12px; /*[cite: 110]*/
  color: #5F5F5F; /*[cite: 110]*/
  background: none; /*[cite: 110]*/
  border: none; /*[cite: 110]*/
  text-decoration: underline; /*[cite: 110]*/
  cursor: pointer;
}

#apply-format-rule {
  font-size: 12px;
  font-weight: 600;
  color: #FFFFFF;
  background-color: #2D2D2D;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
}

#apply-format-rule:hover {
  background-color: #5F5F5F;
}

.lock-icon svg {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.1s;
}

.lock-icon:hover {
  opacity: 1;
}

.lock-icon.active svg path {
  opacity: 1;
  color: #0284c7; /* Cor para indicar que está ativo */
}

.input-wrapper.locked input[type="text"] {
  background-color: #f0f9ff; /* Fundo azul claro para indicar travado */
  border-color: #0ea5e9; /* Borda azul para indicar travado */
}

input[type="text"]:disabled {
  background-color: #F5F5F5;
  color: #AEAEAE;
  cursor: not-allowed;
}

</style>

<div class="plugin-wrapper">
  <div class="tabs-container">
    <div class="tabs-wrapper"> <div class="tabs">
      <div class="tab active" id="tab-texts">Texts</div>
      <div class="tab" id="tab-frames">Frames</div>
      <div class="tab" id="tab-finder">Finder</div>
    </div>

    <button id="formatter-toggle" title="Open/Close Formatter">
      <svg width="24" height="22" viewBox="0 0 24 22" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M21.4791 3.41667H18.2291M13.8958 1.25V5.58333M13.8958 3.41667H1.97913M6.31246 11H1.97913M10.6458 8.83333V13.1667M22.5625 11H10.6458M21.4791 18.5833H18.2291M13.8958 16.4167V20.75M13.8958 18.5833H1.97913" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg></button>
  </div>
  </div>

  <div id="formatter-panel" class="formatter-panel hidden">
    <div class="finder-title">Create Formatting Rule</div>

    <div class="input-wrapper">
      <input type="text" id="format-rule-input" placeholder="Create your role">
    </div>

    <div class="formatter-tokens">
      <div class="token" data-token="{current_text}">Current text</div>
      <div class="token" data-token="{1-9}">1-9</div>
      <div class="token" data-token="{9-1}">9-1</div>
    </div>

    <div class="formatter-panel-footer">
      <button id="clear-format-rule">Clear</button>
      <button id="apply-format-rule">Apply rule</button>
    </div>
  </div>

  <div class="content-area">
    <div id="empty-state" class="container">
      <p style="font-size: 14px;">No text selected</p>
      <p style="font-size: 15px;">
        Select by holding <kbd>Ctrl</kbd> + <kbd>Shift</kbd>
      </p>
    </div>
    <div id="text-list-container" class="text-list hidden"></div>

    <div id="finder-container" class="hidden">
      <div class="finder-section">
        <div class="finder-header">
          <div class="finder-title">Finder</div>
          <div class="finder-nav">
            <button id="finder-prev" disabled>&lt;</button>
            <span id="finder-counter">0/0</span>
            <button id="finder-next" disabled>&gt;</button>
          </div>
        </div>
        <div class="input-wrapper">
          <input type="text" id="find-input" placeholder="What are you looking for?">
          <button id="case-sensitive-toggle">Aa</button>
        </div>
      </div>
      <div class="finder-section">
        <div class="finder-title">Replace</div>
        <div class="input-wrapper">
          <input type="text" id="replace-input" placeholder="Replace with...">
        </div>

      </div>
      <div class="finder-section">
        <div class="finder-title">Preview</div>
        <div class="input-wrapper">
          <textarea id="preview-text" rows="4" readonly></textarea>
        </div>
      </div>

    </div>

    <div id="feedback-container" class="feedback-container hidden">
            <span id="feedback-message"></span>
            <button id="undo-button">Undo</button>
    </div>

  </div>

  <div class="footer hidden" id="footer">
  <div class="finder-actions hidden" id="finder-actions">
    <button id="replace-single" disabled>Replace</button>
    <button id="replace-all" disabled>Replace All</button>
  </div>
  <button id="apply" disabled>Apply<span class="arrow">→</span></button>
</div>
</div>

<div class="plugin-wrapper"></div>

<script>
  const feedbackContainer = document.getElementById('feedback-container');
  const feedbackMessage = document.getElementById('feedback-message');
  const undoButton = document.getElementById('undo-button');

  const tabtexts = document.getElementById('tab-texts');
  const tabFrames = document.getElementById('tab-frames');
  const emptyState = document.getElementById('empty-state');
  const textListContainer = document.getElementById('text-list-container');
  const applyButton = document.getElementById('apply');
  const footer = document.getElementById('footer');

  const tabFinder = document.getElementById('tab-finder');
  const finderContainer = document.getElementById('finder-container');
  const findInput = document.getElementById('find-input');
  const finderCounter = document.getElementById('finder-counter');
  const finderPrev = document.getElementById('finder-prev');
  const finderNext = document.getElementById('finder-next');
  
  const replaceInput = document.getElementById('replace-input');
  const previewText = document.getElementById('preview-text');
  const replaceSingleBtn = document.getElementById('replace-single');
  const replaceAllBtn = document.getElementById('replace-all');
  const caseSensitiveToggle = document.getElementById('case-sensitive-toggle');

  const finderActions = document.getElementById('finder-actions');

  const formatterToggle = document.getElementById('formatter-toggle');
  const formatterPanel = document.getElementById('formatter-panel');
  const formatRuleInput = document.getElementById('format-rule-input');
  const formatterTokens = document.querySelector('.formatter-tokens');
  const clearFormatRuleBtn = document.getElementById('clear-format-rule');

  const applyFormatRuleBtn = document.getElementById('apply-format-rule');


  let activeFormatRule = '';
  let currentMode = 'texts';
  let lastReceivedData = null;
  let currentOriginalNodeText = '';
  let searchResultsCount = 0;
  let isCaseSensitive = false;
  let lockedNodeId = null; // Novo estado para o nodeId travado

  function hideFeedback() {
    feedbackContainer.classList.add('hidden');
  }

  const svgIconLocked = `
    <svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M5 10V6C5 4.67392 5.52678 3.40215 6.46447 2.46447C7.40215 1.52678 8.67392 1 10 1C11.3261 1 12.5979 1.52678 13.5355 2.46447C14.4732 3.40215 15 4.67392 15 6V10M3 10H17C18.1046 10 19 10.8954 19 12V19C19 20.1046 18.1046 21 17 21H3C1.89543 21 1 20.1046 1 19V12C1 10.8954 1.89543 10 3 10Z"
        stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;

  const svgIconUnlocked = `
    <svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M5 10.005V6.00504C4.99875 4.76508 5.45828 3.5689 6.28937 2.6487C7.12047 1.7285 8.26383 1.14994 9.4975 1.02533C10.7312 0.900712 11.9671 1.23894 12.9655 1.97435C13.9638 2.70976 14.6533 3.78988 14.9 5.00504M3 10.005H17C18.1046 10.005 19 10.9005 19 12.005V19.005C19 20.1096 18.1046 21.005 17 21.005H3C1.89543 21.005 1 20.1096 1 19.005V12.005C1 10.9005 1.89543 10.005 3 10.005Z" 
        stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;

  // --- LÓGICA DE TROCA DE ABAS ---
  function setMode(mode) {
    currentMode = mode;
    tabtexts.classList.toggle('active', mode === 'texts');
    tabFrames.classList.toggle('active', mode === 'frames');
    tabFinder.classList.toggle('active', mode === 'finder');

    const isFinderMode = mode === 'finder';
    footer.classList.toggle('hidden', isFinderMode);
    finderContainer.classList.toggle('hidden', !isFinderMode);
    textListContainer.classList.toggle('hidden', isFinderMode);
    emptyState.classList.toggle('hidden', isFinderMode);

    if (!isFinderMode) {
      if (lastReceivedData) {
        renderContent(lastReceivedData);
      }
      // O botão Apply agora pode ser ativado pela formatação
      updateApplyButtonState(); 
    }
  }

  tabtexts.onclick = () => setMode('texts');
  tabFrames.onclick = () => setMode('frames');
  tabFinder.onclick = () => setMode('finder');

  // --- FUNÇÕES DE RENDERIZAÇÃO ---
  function renderContent(data) {
    if (currentMode === 'texts') {
      renderTextView(data.textData);
    } else {
      renderFrameView(data.frameData);
    }
    updateApplyButtonState(); // Atualiza o estado do botão Apply após renderizar
  }

  function renderTextView(textData) {
    const frameIds = Object.keys(textData);
    if (frameIds.length === 0) {
      emptyState.querySelector('p:first-child').textContent = 'No text selected';
      emptyState.classList.remove('hidden');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
    } else {
      emptyState.classList.add('hidden');
      textListContainer.classList.remove('hidden');
      footer.classList.remove('hidden');
      textListContainer.innerHTML = '';
      for (const frameId of frameIds) {
        const frameData = textData[frameId];
        const frameGroup = document.createElement('div');
        frameGroup.className = 'frame-group';
        const title = document.createElement('div');
        title.className = 'frame-title';
        title.textContent = frameData.frameName;
        frameGroup.appendChild(title);
        for (const textNode of frameData.textNodes) {
          const wrapper = document.createElement('div');
          wrapper.className = 'input-wrapper';
          const isLockedNode = lockedNodeId === textNode.nodeId;
          if (isLockedNode) {
            wrapper.classList.add('locked');
          }
          const lockIcon = document.createElement('div');
          lockIcon.className = 'lock-icon';
          
          // --- MUDANÇA AQUI ---
          lockIcon.innerHTML = isLockedNode ? svgIconLocked : svgIconUnlocked;
          if (isLockedNode) {
            lockIcon.classList.add('active');
          }
          // --- FIM DA MUDANÇA ---

          lockIcon.dataset.nodeId = textNode.nodeId;
          const input = document.createElement('input');
          input.type = 'text';
          input.value = textNode.characters;
          input.dataset.nodeId = textNode.nodeId;
          input.dataset.originalText = textNode.characters;

          if (lockedNodeId && !isLockedNode) {
              input.disabled = true;
          }
          
          const resetIcon = document.createElement('img');
          resetIcon.className = 'reset-icon';
          resetIcon.src = "data:image/svg+xml,%3Csvg%20width='16'%20height='15'%20viewBox='0%200%2016%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cpath%20d='M3.72225%201.5L1%203.75M1%203.75L3.72225%206.375M1%203.75H9.94219C12.6189%203.75%2014.892%205.8575%2014.9962%208.4375C15.1067%2011.1637%2012.7706%2013.5%209.94219%2013.5H3.33258'%20stroke='%235F5F5F'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3C/svg%3E";
          
          wrapper.appendChild(lockIcon);
          wrapper.appendChild(input);
          wrapper.appendChild(resetIcon);
          frameGroup.appendChild(wrapper);
        }
        textListContainer.appendChild(frameGroup);
      }
    }
  }

  function renderFrameView(frameData) {
    if (frameData.length === 0) {
      emptyState.querySelector('p:first-child').textContent = 'No frames selected';
      emptyState.classList.remove('hidden');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
    } else {
      emptyState.classList.add('hidden');
      textListContainer.classList.remove('hidden');
      footer.classList.remove('hidden');
      textListContainer.innerHTML = '';
      const frameGroup = document.createElement('div');
      frameGroup.className = 'frame-group';
      for (const frameNode of frameData) {
        const wrapper = document.createElement('div');
        wrapper.className = 'input-wrapper';
        const isLockedNode = lockedNodeId === frameNode.nodeId;
        if (isLockedNode) {
          wrapper.classList.add('locked');
        }
        const lockIcon = document.createElement('div');
        lockIcon.className = 'lock-icon';

        // --- MUDANÇA AQUI ---
        lockIcon.innerHTML = isLockedNode ? svgIconLocked : svgIconUnlocked;
        if (isLockedNode) {
            lockIcon.classList.add('active');
        }
        // --- FIM DA MUDANÇA ---
        
        lockIcon.dataset.nodeId = frameNode.nodeId;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = frameNode.name;
        input.dataset.nodeId = frameNode.nodeId;
        input.dataset.originalText = frameNode.name;

        if (lockedNodeId && !isLockedNode) {
            input.disabled = true;
        }
        
        const resetIcon = document.createElement('img');
        resetIcon.className = 'reset-icon';
        resetIcon.src = "data:image/svg+xml,%3Csvg%20width='16'%20height='15'%20viewBox='0%200%2016%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cpath%20d='M3.72225%201.5L1%203.75M1%203.75L3.72225%206.375M1%203.75H9.94219C12.6189%203.75%2014.892%205.8575%2014.9962%208.4375C15.1067%2011.1637%2012.7706%2013.5%209.94219%2013.5H3.33258'%20stroke='%235F5F5F'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3C/svg%3E";
        
        wrapper.appendChild(lockIcon);
        wrapper.appendChild(input);
        wrapper.appendChild(resetIcon);
        frameGroup.appendChild(wrapper);
      }
      textListContainer.appendChild(frameGroup);
    }
  }

  function updatePreview() {
    const findValue = findInput.value;
    const replaceValue = replaceInput.value;
    if (currentOriginalNodeText === '' || findValue === '') {
      previewText.value = currentOriginalNodeText;
    } else {
      const regex = new RegExp(findValue, isCaseSensitive ? '' : 'i');
      previewText.value = currentOriginalNodeText.replace(regex, replaceValue);
    }
  }

  function updateButtonStates() {
    const hasResults = searchResultsCount > 0;
    const hasReplaceText = replaceInput.value !== '';
    replaceSingleBtn.disabled = !(hasResults && hasReplaceText);
    replaceAllBtn.disabled = !(hasResults && hasReplaceText);
  }
  
  function updateFinderUI(index, count, nodeText = '') {
    searchResultsCount = count;
    currentOriginalNodeText = nodeText;

    const hasResults = count > 0;
    finderCounter.textContent = `${hasResults ? index + 1 : 0}/${count}`;
    finderPrev.disabled = !hasResults;
    finderNext.disabled = !hasResults;

    updatePreview();
    updateButtonStates();
  }
  
  function resetFinderUI() {
    findInput.value = '';
    replaceInput.value = '';
    currentOriginalNodeText = '';
    updateFinderUI(-1, 0);
  }

  function triggerSearch() {
    if (findInput.value.trim() === '') {
      updateFinderUI(-1, 0, '');
      return;
    }
    parent.postMessage({
      pluginMessage: {
        type: 'find-text',
        query: findInput.value,
        isCaseSensitive: isCaseSensitive
      }
    }, '*');
  }

  window.onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg.type !== 'replace-success') {
        hideFeedback();
    }
    
    switch (msg.type) {
        case 'selectionChange':
            lastReceivedData = msg;
            if (currentMode !== 'finder') {
                // Preserva o estado do lock ao mudar a seleção
                const currentLockedNode = lockedNodeId ? document.querySelector(`[data-node-id="${lockedNodeId}"]`) : null;
                if (!currentLockedNode || (currentMode === 'texts' && !msg.textData[Object.keys(msg.textData).find(frameId => msg.textData[frameId].textNodes.some(node => node.nodeId === lockedNodeId))]) || (currentMode === 'frames' && !msg.frameData.some(node => node.nodeId === lockedNodeId))) {
                    lockedNodeId = null; // Limpa o lock se o nó não estiver mais selecionado
                }
                renderContent(lastReceivedData);
            }
            break;
        
        case 'search-result':
        case 'navigation-update':
            updateFinderUI(msg.index, msg.count, msg.nodeText);
            break;

        case 'replace-success':
            feedbackMessage.textContent = `${msg.count} ${msg.count > 1 ? 'replaced items' : 'replaced item'}.`;
            feedbackContainer.classList.remove('hidden');
            
            if (msg.allReplaced) {
                resetFinderUI();
            } else if (msg.updatedNode) {
                updateFinderUI(msg.updatedNode.index, msg.updatedNode.count, msg.updatedNode.nodeText);
            }
            break;

        case 'apply-success':
            feedbackMessage.textContent = `${msg.count} ${msg.count > 1 ? 'items updated' : 'item updated'}.`;
            feedbackContainer.classList.remove('hidden');
            break;
            
        case 'all-replace-success':
            resetFinderUI();
            break;

        case 'hide-undo':
             hideFeedback();
             break;

        case 'undo-complete':
            hideFeedback();
            triggerSearch();
            break;
    }
  };

  // --- LÓGICA DO PAINEL DE FORMATAÇÃO ---

  formatterToggle.addEventListener('click', () => {
    formatterPanel.classList.toggle('hidden');
  });

  formatterTokens.addEventListener('click', (event) => {
    if (event.target.classList.contains('token')) {
      const token = event.target.dataset.token;
      const input = formatRuleInput;

      // Adiciona um espaço se o input não estiver vazio
      const prefix = input.value ? input.value + ' ' : '';

      if (token === '{text=}') {
        input.value = prefix + '{text=SUA_STRING}';
      } else {
        input.value = prefix + token;
      }
      updateApplyButtonState(); // Ativa o botão Apply ao adicionar um token
    }
  });

  clearFormatRuleBtn.addEventListener('click', () => {
    formatRuleInput.value = '';
    activeFormatRule = ''; // Limpa a regra ativa
    formatterToggle.classList.remove('active'); // Desativa a cor do ícone
    updateApplyButtonState(); // Atualiza o estado do botão Apply
  });

  undoButton.onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'undo-last-change' } }, '*');
  };

  findInput.addEventListener('input', () => {
      hideFeedback();
      triggerSearch();
  });
  replaceInput.addEventListener('input', () => {
      hideFeedback();
      updatePreview();
      updateButtonStates();
  });

  applyFormatRuleBtn.addEventListener('click', () => {
    activeFormatRule = formatRuleInput.value.trim();

    if (activeFormatRule) {
      formatterToggle.classList.add('active'); // Ativa a cor do ícone
    } else {
      formatterToggle.classList.remove('active'); // Remove a cor se a regra estiver vazia
    }

    formatterPanel.classList.add('hidden'); // Fecha o painel
    updateApplyButtonState(); // Ativa o botão Apply ao aplicar a regra
  });
  
  textListContainer.addEventListener('input', (event) => {
    if (event.target.tagName === 'INPUT') {
      const input = event.target;
      const resetIcon = input.nextElementSibling;
      
      if (input.value !== input.dataset.originalText) {
        resetIcon.classList.add('visible');
      } else {
        resetIcon.classList.remove('visible');
      }
      updateApplyButtonState(); // Atualiza o estado do botão Apply
    }
  });

  applyButton.onclick = () => {
    const inputs = textListContainer.querySelectorAll('input[type="text"]');
    const changes = [];
    const formatRule = activeFormatRule;
    let lockedTextContent = '';

    if (lockedNodeId) {
      const lockedInput = document.querySelector(`input[data-node-id="${lockedNodeId}"]`);
      if (lockedInput) {
        lockedTextContent = lockedInput.value;
      }
    }

    inputs.forEach((input, index) => {
      const nodeId = input.dataset.nodeId;
      const originalText = input.dataset.originalText;
      let newText = input.value;

      if (lockedNodeId && nodeId !== lockedNodeId) {
        newText = lockedTextContent;
      } else if (formatRule) {
        const totalItems = inputs.length;
        const formattedText = applyFormatRule(formatRule, originalText, index, totalItems);
        if (input.value !== originalText && !lockedNodeId) {
            newText = input.value;
        } else {
            newText = formattedText;
        }
      }

      if (newText !== originalText) {
        if (currentMode === 'texts') {
          changes.push({ nodeId: nodeId, newText: newText });
        } else {
          changes.push({ nodeId: nodeId, newName: newText });
        }
      }
    });

    if (changes.length > 0) {
      const messageType = currentMode === 'texts' ? 'apply-changes' : 'apply-frame-name-changes';
      parent.postMessage({ pluginMessage: { type: messageType, data: changes } }, '*');
    }
    
    // --- INÍCIO DA CORREÇÃO 2 ---
    // Após aplicar, atualize a "fonte da verdade" (lastReceivedData) e a UI.
    if (lastReceivedData) {
        // Primeiro, aplicamos as alterações que foram enviadas ao Figma
        changes.forEach(change => {
            const newValue = currentMode === 'texts' ? change.newText : change.newName;
            if (currentMode === 'texts') {
                for (const frameId in lastReceivedData.textData) {
                    const nodeInfo = lastReceivedData.textData[frameId].textNodes.find(n => n.nodeId === change.nodeId);
                    if (nodeInfo) nodeInfo.characters = newValue;
                }
            } else {
                const nodeInfo = lastReceivedData.frameData.find(n => n.nodeId === change.nodeId);
                if (nodeInfo) nodeInfo.name = newValue;
            }
        });

        // Se o lock estava ativo, precisamos garantir que o item que serviu de fonte (o próprio item lockado)
        // também tenha seu 'originalText' atualizado em `lastReceivedData`
        if(lockedNodeId){
            const lockedItemChange = changes.find(c => c.nodeId === lockedNodeId);
            if(!lockedItemChange) { // Caso o próprio item lockado não tenha mudado, forçamos a atualização
                 if (currentMode === 'texts') {
                    for (const frameId in lastReceivedData.textData) {
                        const nodeInfo = lastReceivedData.textData[frameId].textNodes.find(n => n.nodeId === lockedNodeId);
                        if (nodeInfo) nodeInfo.characters = lockedTextContent;
                    }
                } else {
                    const nodeInfo = lastReceivedData.frameData.find(n => n.nodeId === lockedNodeId);
                    if (nodeInfo) nodeInfo.name = lockedTextContent;
                }
            }
        }
    }
    
    // Como a ação foi concluída, podemos limpar o estado de lock
    lockedNodeId = null;

    // Agora, re-renderizamos toda a UI com os dados corretos e atualizados
    renderContent(lastReceivedData);
    // --- FIM DA CORREÇÃO 2 ---

    if (!activeFormatRule) {
      formatterPanel.classList.add('hidden');
      formatterToggle.classList.remove('active');
    }
    
    updateApplyButtonState();
  };

  textListContainer.addEventListener('click', (event) => {
      const resetIcon = event.target.closest('.reset-icon');
      if (resetIcon) {
        const wrapper = resetIcon.parentElement;
        const input = wrapper.querySelector('input');
        
        input.value = input.dataset.originalText;
        resetIcon.classList.remove('visible');
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }

      const lockIcon = event.target.closest('.lock-icon');
      if (lockIcon) {
        const nodeIdToLock = lockIcon.dataset.nodeId;
        
        // --- INÍCIO DA CORREÇÃO 1 ---
        // Antes de qualquer coisa, vamos capturar o valor atual do input que está sendo "lockado"
        const inputElement = lockIcon.parentElement.querySelector('input');
        const currentInputValue = inputElement.value;

        // Agora, atualizamos nossa "fonte da verdade" (lastReceivedData) com este valor.
        // Assim, a re-renderização não perderá a edição manual.
        if (lastReceivedData) {
          if (currentMode === 'texts') {
              for (const frameId in lastReceivedData.textData) {
                  const textNodeInfo = lastReceivedData.textData[frameId].textNodes.find(n => n.nodeId === nodeIdToLock);
                  if (textNodeInfo) {
                      textNodeInfo.characters = currentInputValue;
                      break; 
                  }
              }
          } else { // modo 'frames'
              const frameNodeInfo = lastReceivedData.frameData.find(n => n.nodeId === nodeIdToLock);
              if (frameNodeInfo) {
                  frameNodeInfo.name = currentInputValue;
              }
          }
        }
        // --- FIM DA CORREÇÃO 1 ---

        if (lockedNodeId === nodeIdToLock) {
          lockedNodeId = null; // Desativa o lock
        } else {
          lockedNodeId = nodeIdToLock; // Ativa o lock
        }
        
        renderContent(lastReceivedData); // Agora, re-renderiza com os dados já atualizados
        updateApplyButtonState(); 
      }
  });

  function applyFormatRule(rule, originalText, index, totalItems) {
    if (!rule) return originalText; // Retorna o original se não houver regra

    let result = rule;

    // 1. Substitui o texto atual
    result = result.replace(/\{current_text\}/g, originalText);

    // 2. Substitui o número crescente (base 1)
    result = result.replace(/\{1-9\}/g, String(index + 1));

    // 3. Substitui o número decrescente
    result = result.replace(/\{9-1\}/g, String(totalItems - index));

    // 4. Substitui o texto fixo (ex: {text=Hello World})
    result = result.replace(/\{text=(.*?)\}/g, (match, p1) => p1);

    return result.trim();
  }

  function updateApplyButtonState() {
    let hasManualChanges = false;
    const inputs = textListContainer.querySelectorAll('input[type="text"]');
    for (const input of inputs) {
      if (input.value !== input.dataset.originalText) {
        hasManualChanges = true;
        break;
      }
    }
    // O botão Apply fica ativo se houver formatação ativa OU se houver mudanças manuais OU se houver um item travado
    applyButton.disabled = !(activeFormatRule || hasManualChanges || lockedNodeId);
  }

  

  findInput.addEventListener('input', triggerSearch);
  replaceInput.addEventListener('input', () => {
    updatePreview();
    updateButtonStates();
  });
  
  caseSensitiveToggle.onclick = () => {
    isCaseSensitive = !isCaseSensitive;
    caseSensitiveToggle.classList.toggle('active', isCaseSensitive);
    triggerSearch();
  };

  finderNext.onclick = () => { parent.postMessage({ pluginMessage: { type: 'navigate', direction: 'next' } }, '*'); };
  finderPrev.onclick = () => { parent.postMessage({ pluginMessage: { type: 'navigate', direction: 'prev' } }, '*'); };

  replaceSingleBtn.onclick = () => {
    parent.postMessage({ 
      pluginMessage: { 
        type: 'replace-single',
        findText: findInput.value,
        replaceText: replaceInput.value,
        isCaseSensitive: isCaseSensitive
      } 
    }, '*');
  };

  replaceAllBtn.onclick = () => {
    parent.postMessage({ 
      pluginMessage: { 
        type: 'replace-all',
        findText: findInput.value,
        replaceText: replaceInput.value,
        isCaseSensitive: isCaseSensitive
      } 
    }, '*');
  };

  tabFinder.addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.remove('hidden');
    applyButton.classList.add('hidden'); // Esconde o botão Apply na aba Finder
  });

  document.getElementById('tab-texts').addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.add('hidden');
    applyButton.classList.remove('hidden');
    updateApplyButtonState(); // Garante que o botão Apply seja atualizado ao mudar de aba
  });

  document.getElementById('tab-frames').addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.add('hidden');
    applyButton.classList.remove('hidden');
    updateApplyButtonState(); // Garante que o botão Apply seja atualizado ao mudar de aba
  });

  // Inicializa o estado do botão Apply
  updateButtonStates();
  updateApplyButtonState();
</script>
