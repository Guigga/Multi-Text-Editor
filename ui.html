<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    margin: 0;
    padding: 0;
    background-color: #EFEFEF;
    color: #2D2D2D;
    overflow: hidden; 
  }

  /* --- Estrutura Principal --- */
  .plugin-wrapper {
    display: flex;
    flex-direction: column;
    height: 100vh; /* Ocupa toda a altura da janela do plugin */
  }
  
  /* --- 1. Área das Abas --- */
  .tabs-container {
    background-color: #FFFFFF;
    padding: 16px;
    border-bottom: 1px solid #AEAEAE;
    flex-shrink: 0;
  }

  .tabs {
    display: flex;
  }

  .tab {
    font-size: 14px;
    margin-right: 16px;
    cursor: pointer;
    font-weight: 400;
    color: #AEAEAE;
  }

  .tab.active {
    font-weight: 600;
    color: #2D2D2D;
  }
  
  /* --- 2. Área de Conteúdo (Inputs) --- */
  .content-area {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px;
  }

  .container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    color: #5F5F5F;
    height: 100%;
  }
  .container p {
    margin: 0;
  }
  .container p:last-child {
    font-size: 12px;
    margin-top: 4px;
  }

  .text-list {
    width: 100%;
    text-align: left;
  }

  .frame-group {
    margin-bottom: 16px;
  }

  .frame-title {
    font-size: 13px;
    font-weight: 600;
    color: #2D2D2D;
    margin-bottom: 8px;
  }

  .input-wrapper {
    position: relative;
    width: 100%;
    margin-bottom: 8px;
  }

  input[type="text"] {
    width: 100%;
    padding: 12px 12px;
    padding-right: 32px;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    box-sizing: border-box;
    background-color: #FFFFFF;
    transition: border-color 0.2s;

    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 400;
    color: #5F5F5F;
  }
  input[type="text"]:focus {
    outline: none;
    border: 1px solid #2D2D2D;
  }

  .reset-icon {
    position: absolute;
    right: 40px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 16px;
    cursor: pointer;
    transition: opacity 0.1s, visibility 0.2s;
    visibility: hidden;
    color: #5F5F5F;
    opacity: 0.5 ;
  }
  .reset-icon:hover { opacity: 1; }
  .reset-icon.visible { visibility: visible; }

  .footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 20px;
    background-color: #FFFFFF;
    border-top: 0.5px solid #AEAEAE;
    flex-shrink: 0;
  }

  button {
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600; /* Semibold */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
  }

  /* Botão Aplicar */
  button#apply {
    /* Padding para guiar o tamanho */
    padding: 12px 20px;
  }
  
  .arrow {
    margin-left: 8px; /* Espaçamento do texto para a seta */
    transition: color 0.2s;
  }

  /* Estado Ativado do Aplicar */
  button#apply {
    background: #2D2D2D;
    color: #FFFFFF;
  }

  /* Estado Desativado do Aplicar */
  button#apply:disabled {
    background: #DFDFDF;
    color: #5F5F5F;
    cursor: not-allowed;
  }

  .hidden {
    display: none;
  }

  .finder-section { margin-bottom: 16px; }
  .finder-header { display: flex; justify-content: space-between; align-items: center; }
  .finder-title { font-size: 13px; font-weight: 600; color: #2D2D2D; margin-bottom: 4px; }
  .finder-nav { display: flex; align-items: center; gap: 2px; margin-bottom: 1px; }
  .finder-nav span { font-size: 13px; color: #5F5F5F; min-width: 40px; text-align: center; }
  .finder-nav button { background-color: transparent; color: #5F5F5F; padding: 4px 6px; border-radius: 8px; }
  .finder-nav button:disabled { color: #C1C1C1; border-color: #EFEFEF; cursor: not-allowed; }
  .finder-nav button:hover:not(:disabled) { background-color: transparent; }

  .finder-footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 20px 16px; /* antes era apenas 20px */
    background-color: #FFFFFF;
    border-top: 0.5px solid #AEAEAE;
    flex-shrink: 0;
    margin-top: auto;
  }

  .finder-actions {
    display: flex;
    gap: 8px;
  }

  .finder-actions button {
    padding: 12px 20px;
    font-size: 14px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    border-radius: 6px;
    cursor: pointer;
  }
  #replace-single {
    background-color: #FFFFFF;
    color: #2D2D2D;
    border: 1px solid #AEAEAE;
  }

  #replace-all {
    background-color: #2D2D2D;
    color: #FFFFFF;
    border: none;
  }
  .finder-actions button:disabled {
    background: #DFDFDF;
    color: #5F5F5F;
    cursor: not-allowed;
    border-color: transparent;
  }
  #find-input {
    /* Adiciona espaço à direita para o botão não sobrepor o texto */
    padding-right: 40px; 
  }
  #case-sensitive-toggle {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #AEAEAE;
    font-size: 14px;
    line-height: 1;
    font-weight: 700;
  }
  #case-sensitive-toggle:hover {
    background-color: #f0f0f0;
  }
  #case-sensitive-toggle.active {
    background-color: #e0e0e0;
    color: #2D2D2D;
  }

  .feedback-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e0f2fe;
    color: #0c4a6e;
    padding: 8px 12px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 8px;
  }

  .kbd, kbd {
    background-color: #F5F5F5;
    border: 1px solid #CCC;
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 12px;
    font-family: 'Inter', monospace;
    box-shadow: inset 0 -1px 0 #BBB;
    color: #2D2D2D;
    margin: 0 2px;
  }

  #undo-button {
    background: none;
    border: 1px solid #0ea5e9;
    color: #0284c7;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  #undo-button:hover {
    background-color: #f0f9ff;
  }

  #preview-text {
    width: 100%;
    height: 96px;
    resize: none;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    padding: 12px;
    background-color: #F5F5F5;
    color: #5F5F5F;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    box-sizing: border-box;
  }

  .hidden {
    display: none !important;
  }

  .tabs-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  #formatter-toggle {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
    border-radius: 4px;
    margin-left: 16px;
  }
  #formatter-toggle:hover {
    opacity: 1;
    background-color: #f0f0f0;
  }
  #formatter-toggle.active {
    opacity: 1;
    background-color: #e0f2fe; /* Azul claro para indicar regra ativa */
  }

  /* O SVG precisa ter seu stroke alterado para que a cor funcione melhor */
  #formatter-toggle.active svg path {
    stroke: #0c4a6e; /* Azul escuro para contraste */
  }
  #formatter-toggle svg {
    display: block;
    width: 16px;
    height: 16px;
  }

  .formatter-panel {
    position: absolute;
    top: 55px; /* Abaixo da barra de abas */
    right: 16px;
    left: 16px;
    background-color: #FFFFFF;
    border: 1px solid #AEAEAE;
    border-radius: 8px;
    padding: 12px;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  .formatter-panel .finder-title {
    margin-bottom: 8px;
  }
  .formatter-tokens {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
  }
  .formatter-tokens .token {
    background-color: #e0e0e0;
    color: #2D2D2D;
    font-size: 12px;
    font-weight: 500;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
  }
  .formatter-panel-footer {
    display: flex;
    justify-content: flex-end;
    margin-top: 12px;
  }
  #clear-format-rule {
    font-size: 12px;
    color: #5F5F5F;
    background: none;
    border: none;
    text-decoration: underline;
    margin-right: 8px;
  }

/* --- Estilos para o Wrapper das Abas --- */
.tabs-wrapper {
  display: flex; /*[cite: 99]*/
  justify-content: space-between; /*[cite: 99]*/
  align-items: center; /*[cite: 99]*/
}

#formatter-toggle {
  background: none; /*[cite: 100]*/
  border: none; /*[cite: 100]*/
  padding: 4px; /*[cite: 100]*/
  cursor: pointer; /*[cite: 100]*/
  opacity: 0.5; /*[cite: 100]*/
  transition: opacity 0.2s, background-color 0.2s; /*[cite: 101]*/
  border-radius: 4px; /*[cite: 101]*/
}
#formatter-toggle:hover {
  opacity: 1; /*[cite: 101]*/
  background-color: #f0f0f0; /*[cite: 101]*/
}
#formatter-toggle.active {
  opacity: 1; /*[cite: 102]*/
  background-color: #e0f2fe; /*[cite: 102]*/
}
#formatter-toggle svg {
  display: block; /*[cite: 103]*/
  width: 16px; /*[cite: 103]*/
  height: 16px; /*[cite: 103]*/
}

/* --- Estilos para o Painel de Formatação --- */
.formatter-panel {
  position: absolute; /*[cite: 104]*/
  top: 55px; /*[cite: 104]*/
  right: 16px; /*[cite: 105]*/
  left: 16px; /*[cite: 105]*/
  background-color: #FFFFFF; /*[cite: 105]*/
  border: 1px solid #AEAEAE; /*[cite: 105]*/
  border-radius: 8px; /*[cite: 106]*/
  padding: 12px; /*[cite: 106]*/
  z-index: 10; /*[cite: 106]*/
  box-shadow: 0 4px 12px rgba(0,0,0,0.1); /*[cite: 106]*/
}
.formatter-panel .finder-title {
  margin-bottom: 8px;
}
.formatter-tokens {
  display: flex; /*[cite: 107]*/
  flex-wrap: wrap; /*[cite: 107]*/
  gap: 8px; /*[cite: 107]*/
  margin-top: 8px; /*[cite: 107]*/
}
.formatter-tokens .token {
  background-color: #e0e0e0; /*[cite: 108]*/
  color: #2D2D2D; /*[cite: 108]*/
  font-size: 12px; /*[cite: 108]*/
  font-weight: 500; /*[cite: 108]*/
  padding: 4px 8px; /*[cite: 108]*/
  border-radius: 4px; /*[cite: 108]*/
  cursor: pointer; /*[cite: 108]*/
}
.formatter-panel-footer {
  display: flex; /*[cite: 109]*/
  justify-content: flex-end; /*[cite: 109]*/
  margin-top: 12px; /*[cite: 109]*/
}
#clear-format-rule {
  font-size: 12px; /*[cite: 110]*/
  color: #5F5F5F; /*[cite: 110]*/
  background: none; /*[cite: 110]*/
  border: none; /*[cite: 110]*/
  text-decoration: underline; /*[cite: 110]*/
  cursor: pointer;
}

#apply-format-rule {
  font-size: 12px;
  font-weight: 600;
  color: #FFFFFF;
  background-color: #2D2D2D;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
}

#apply-format-rule:hover {
  background-color: #5F5F5F;
}

.lock-icon svg {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.1s;
}

.lock-icon:hover {
  opacity: 1;
}

.lock-icon.active svg path {
  opacity: 1;
  color: #0284c7; /* Cor para indicar que está ativo */
}

.input-wrapper.locked input[type="text"] {
  background-color: #f0f9ff; /* Fundo azul claro para indicar travado */
  border-color: #0ea5e9; /* Borda azul para indicar travado */
}

.input-wrapper.locked .reset-icon {
  display: none; /* Esconde o reset icon quando travado */
}

</style>

<div class="plugin-wrapper">
  <div class="tabs-container">
    <div class="tabs-wrapper"> <div class="tabs">
      <div class="tab active" id="tab-texts">Texts</div>
      <div class="tab" id="tab-frames">Frames</div>
      <div class="tab" id="tab-finder">Finder</div>
    </div>

    <button id="formatter-toggle" title="Open/Close Formatter">
      <svg width="24" height="22" viewBox="0 0 24 22" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M21.4791 3.41667H18.2291M13.8958 1.25V5.58333M13.8958 3.41667H1.97913M6.31246 11H1.97913M10.6458 8.83333V13.1667M22.5625 11H10.6458M21.4791 18.5833H18.2291M13.8958 16.4167V20.75M13.8958 18.5833H1.97913" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg></button>
  </div>
  </div>

  <div id="formatter-panel" class="formatter-panel hidden">
    <div class="finder-title">Create Formatting Rule</div>

    <div class="input-wrapper">
      <input type="text" id="format-rule-input">
    </div>

    <div class="formatter-tokens">
      <div class="token" data-token="{current_text}">Current text</div>
      <div class="token" data-token="{1-9}">1-9</div>
      <div class="token" data-token="{9-1}">9-1</div>
    </div>

    <div class="formatter-panel-footer">
      <button id="clear-format-rule">Clear</button>
      <button id="apply-format-rule">Apply rule</button>
    </div>
  </div>

  <div class="content-area">
    <div id="empty-state" class="container">
      <p style="font-size: 14px;">No text selected</p>
      <p style="font-size: 15px;">
        Select by holding <kbd>Ctrl</kbd> + <kbd>Shift</kbd>
      </p>
    </div>
    <div id="text-list-container" class="text-list hidden"></div>

    <div id="finder-container" class="hidden">
      <div class="finder-section">
        <div class="finder-header">
          <div class="finder-title">Finder</div>
          <div class="finder-nav">
            <button id="finder-prev" disabled>&lt;</button>
            <span id="finder-counter">0/0</span>
            <button id="finder-next" disabled>&gt;</button>
          </div>
        </div>
        <div class="input-wrapper">
          <input type="text" id="find-input" placeholder="What are you looking for?">
          <button id="case-sensitive-toggle">Aa</button>
        </div>
      </div>
      <div class="finder-section">
        <div class="finder-title">Replace</div>
        <div class="input-wrapper">
          <input type="text" id="replace-input" placeholder="Replace with...">
        </div>

      </div>
      <div class="finder-section">
        <div class="finder-title">Preview</div>
        <div class="input-wrapper">
          <textarea id="preview-text" rows="4" readonly></textarea>
        </div>
      </div>

      <div id="feedback-container" class="feedback-container hidden">
            <span id="feedback-message"></span>
            <button id="undo-button">Undo</button>
        </div>
    </div>
  </div>

  <div class="footer hidden" id="footer">
  <div class="finder-actions hidden" id="finder-actions">
    <button id="replace-single" disabled>Replace</button>
    <button id="replace-all" disabled>Replace All</button>
  </div>
  <button id="apply" disabled>Apply<span class="arrow">→</span></button>
</div>
</div>

<div class="plugin-wrapper"></div>

<script>
  const feedbackContainer = document.getElementById('feedback-container');
  const feedbackMessage = document.getElementById('feedback-message');
  const undoButton = document.getElementById('undo-button');

  const tabtexts = document.getElementById('tab-texts');
  const tabFrames = document.getElementById('tab-frames');
  const emptyState = document.getElementById('empty-state');
  const textListContainer = document.getElementById('text-list-container');
  const applyButton = document.getElementById('apply');
  const footer = document.getElementById('footer');

  const tabFinder = document.getElementById('tab-finder');
  const finderContainer = document.getElementById('finder-container');
  const findInput = document.getElementById('find-input');
  const finderCounter = document.getElementById('finder-counter');
  const finderPrev = document.getElementById('finder-prev');
  const finderNext = document.getElementById('finder-next');
  
  const replaceInput = document.getElementById('replace-input');
  const previewText = document.getElementById('preview-text');
  const replaceSingleBtn = document.getElementById('replace-single');
  const replaceAllBtn = document.getElementById('replace-all');
  const caseSensitiveToggle = document.getElementById('case-sensitive-toggle');

  const finderActions = document.getElementById('finder-actions');

  const formatterToggle = document.getElementById('formatter-toggle');
  const formatterPanel = document.getElementById('formatter-panel');
  const formatRuleInput = document.getElementById('format-rule-input');
  const formatterTokens = document.querySelector('.formatter-tokens');
  const clearFormatRuleBtn = document.getElementById('clear-format-rule');

  const applyFormatRuleBtn = document.getElementById('apply-format-rule');

  let activeFormatRule = '';
  let currentMode = 'texts';
  let lastReceivedData = null;
  let currentOriginalNodeText = '';
  let searchResultsCount = 0;
  let isCaseSensitive = false;
  let lockedNodeId = null; // Novo estado para o nodeId travado

  function hideFeedback() {
    feedbackContainer.classList.add('hidden');
  }

  // --- LÓGICA DE TROCA DE ABAS ---
  function setMode(mode) {
    currentMode = mode;
    tabtexts.classList.toggle('active', mode === 'texts');
    tabFrames.classList.toggle('active', mode === 'frames');
    tabFinder.classList.toggle('active', mode === 'finder');

    const isFinderMode = mode === 'finder';
    footer.classList.toggle('hidden', isFinderMode);
    finderContainer.classList.toggle('hidden', !isFinderMode);
    textListContainer.classList.toggle('hidden', isFinderMode);
    emptyState.classList.toggle('hidden', isFinderMode);

    if (!isFinderMode) {
      if (lastReceivedData) {
        renderContent(lastReceivedData);
      }
      // O botão Apply agora pode ser ativado pela formatação
      updateApplyButtonState(); 
    }
  }

  tabtexts.onclick = () => setMode('texts');
  tabFrames.onclick = () => setMode('frames');
  tabFinder.onclick = () => setMode('finder');

  // --- FUNÇÕES DE RENDERIZAÇÃO ---
  function renderContent(data) {
    if (currentMode === 'texts') {
      renderTextView(data.textData);
    } else {
      renderFrameView(data.frameData);
    }
    updateApplyButtonState(); // Atualiza o estado do botão Apply após renderizar
  }

  function renderTextView(textData) {
    const frameIds = Object.keys(textData);
    if (frameIds.length === 0) {
      emptyState.querySelector('p:first-child').textContent = 'No text selected';
      emptyState.classList.remove('hidden');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
    } else {
      emptyState.classList.add('hidden');
      textListContainer.classList.remove('hidden');
      footer.classList.remove('hidden');
      textListContainer.innerHTML = '';
      for (const frameId of frameIds) {
        const frameData = textData[frameId];
        const frameGroup = document.createElement('div');
        frameGroup.className = 'frame-group';
        const title = document.createElement('div');
        title.className = 'frame-title';
        title.textContent = frameData.frameName;
        frameGroup.appendChild(title);
        for (const textNode of frameData.textNodes) {
          const wrapper = document.createElement('div');
          wrapper.className = 'input-wrapper';
          if (lockedNodeId === textNode.nodeId) {
            wrapper.classList.add('locked');
          }
          const lockIcon = document.createElement('div');
          lockIcon.className = 'lock-icon';
          lockIcon.innerHTML = `
            <svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M5 10V6C5 4.67392 5.52678 3.40215 6.46447 2.46447C7.40215 1.52678 8.67392 1 10 1C11.3261 1 12.5979 1.52678 13.5355 2.46447C14.4732 3.40215 15 4.67392 15 6V10M3 10H17C18.1046 10 19 10.8954 19 12V19C19 20.1046 18.1046 21 17 21H3C1.89543 21 1 20.1046 1 19V12C1 10.8954 1.89543 10 3 10Z"
                stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          `;
          lockIcon.dataset.nodeId = textNode.nodeId;
          if (lockedNodeId === textNode.nodeId) {
            lockIcon.classList.add('active');
          }

          const input = document.createElement('input');
          input.type = 'text';
          input.value = textNode.characters;
          input.dataset.nodeId = textNode.nodeId;
          input.dataset.originalText = textNode.characters;
          const resetIcon = document.createElement('img');
          resetIcon.className = 'reset-icon';
          resetIcon.src = "data:image/svg+xml,%3Csvg%20width='16'%20height='15'%20viewBox='0%200%2016%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cpath%20d='M3.72225%201.5L1%203.75M1%203.75L3.72225%206.375M1%203.75H9.94219C12.6189%203.75%2014.892%205.8575%2014.9962%208.4375C15.1067%2011.1637%2012.7706%2013.5%209.94219%2013.5H3.33258'%20stroke='%235F5F5F'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3C/svg%3E";
          
          wrapper.appendChild(lockIcon); // Adiciona o ícone de lock
          wrapper.appendChild(input);
          wrapper.appendChild(resetIcon);
          frameGroup.appendChild(wrapper);
        }
        textListContainer.appendChild(frameGroup);
      }
    }
  }

  function renderFrameView(frameData) {
    if (frameData.length === 0) {
      emptyState.querySelector('p:first-child').textContent = 'No frames selected';
      emptyState.classList.remove('hidden');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
    } else {
      emptyState.classList.add('hidden');
      textListContainer.classList.remove('hidden');
      footer.classList.remove('hidden');
      textListContainer.innerHTML = '';
      const frameGroup = document.createElement('div');
      frameGroup.className = 'frame-group';
      for (const frameNode of frameData) {
        const wrapper = document.createElement('div');
        wrapper.className = 'input-wrapper';
        if (lockedNodeId === frameNode.nodeId) {
          wrapper.classList.add('locked');
        }
        const lockIcon = document.createElement('img');
        lockIcon.className = 'lock-icon';
        lockIcon.src = "data:image/svg+xml,%3Csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cpath%20d='M12.6667%207.33333H3.33333C2.59695%207.33333%202%207.93029%202%208.66667V13.3333C2%2014.0697%202.59695%2014.6667%203.33333%2014.6667H12.6667C13.403%2014.6667%2014%2014.0697%2014%2013.3333V8.66667C14%207.93029%2013.403%207.33333%2012.6667%207.33333Z'%20stroke='%235F5F5F'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3Cpath%20d='M4.66667%207.33333V4.66667C4.66667%203.38696%205.18452%202.15362%206.09835%201.2398C7.01219%200.325975%208.24553%200.00012207%209.52524%200.00012207C10.805%200.00012207%2012.0383%200.325975%2012.9522%201.2398C13.866%202.15362%2014.3839%203.38696%2014.3839%204.66667V7.33333H4.66667Z'%20stroke='%235F5F5F'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3C/svg%3E";
        lockIcon.dataset.nodeId = frameNode.nodeId;
        if (lockedNodeId === frameNode.nodeId) {
          lockIcon.classList.add('active');
        }

        const input = document.createElement('input');
        input.type = 'text';
        input.value = frameNode.name;
        input.dataset.nodeId = frameNode.nodeId;
        input.dataset.originalText = frameNode.name;
        const resetIcon = document.createElement('img');
        resetIcon.className = 'reset-icon';
        resetIcon.src = "data:image/svg+xml,%3Csvg%20width='16'%20height='15'%20viewBox='0%200%2016%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cpath%20d='M3.72225%201.5L1%203.75M1%203.75L3.72225%206.375M1%203.75H9.94219C12.6189%203.75%2014.892%205.8575%2014.9962%208.4375C15.1067%2011.1637%2012.7706%2013.5%209.94219%2013.5H3.33258'%20stroke='%235F5F5F'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3E%3C/svg%3E";
        
        wrapper.appendChild(lockIcon); // Adiciona o ícone de lock
        wrapper.appendChild(input);
        wrapper.appendChild(resetIcon);
        frameGroup.appendChild(wrapper);
      }
      textListContainer.appendChild(frameGroup);
    }
  }

  function updatePreview() {
    const findValue = findInput.value;
    const replaceValue = replaceInput.value;
    if (currentOriginalNodeText === '' || findValue === '') {
      previewText.value = currentOriginalNodeText;
    } else {
      const regex = new RegExp(findValue, isCaseSensitive ? '' : 'i');
      previewText.value = currentOriginalNodeText.replace(regex, replaceValue);
    }
  }

  function updateButtonStates() {
    const hasResults = searchResultsCount > 0;
    const hasReplaceText = replaceInput.value !== '';
    replaceSingleBtn.disabled = !(hasResults && hasReplaceText);
    replaceAllBtn.disabled = !(hasResults && hasReplaceText);
  }
  
  function updateFinderUI(index, count, nodeText = '') {
    searchResultsCount = count;
    currentOriginalNodeText = nodeText;

    const hasResults = count > 0;
    finderCounter.textContent = `${hasResults ? index + 1 : 0}/${count}`;
    finderPrev.disabled = !hasResults;
    finderNext.disabled = !hasResults;

    updatePreview();
    updateButtonStates();
  }
  
  function resetFinderUI() {
    findInput.value = '';
    replaceInput.value = '';
    currentOriginalNodeText = '';
    updateFinderUI(-1, 0);
  }

  function triggerSearch() {
    if (findInput.value.trim() === '') {
      updateFinderUI(-1, 0, '');
      return;
    }
    parent.postMessage({
      pluginMessage: {
        type: 'find-text',
        query: findInput.value,
        isCaseSensitive: isCaseSensitive
      }
    }, '*');
  }

  window.onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg.type !== 'replace-success') {
        hideFeedback();
    }
    
    switch (msg.type) {
        case 'selectionChange':
            lastReceivedData = msg;
            if (currentMode !== 'finder') {
                // Preserva o estado do lock ao mudar a seleção
                const currentLockedNode = lockedNodeId ? document.querySelector(`[data-node-id="${lockedNodeId}"]`) : null;
                if (!currentLockedNode || (currentMode === 'texts' && !msg.textData[Object.keys(msg.textData).find(frameId => msg.textData[frameId].textNodes.some(node => node.nodeId === lockedNodeId))]) || (currentMode === 'frames' && !msg.frameData.some(node => node.nodeId === lockedNodeId))) {
                    lockedNodeId = null; // Limpa o lock se o nó não estiver mais selecionado
                }
                renderContent(lastReceivedData);
            }
            break;
        
        case 'search-result':
        case 'navigation-update':
            updateFinderUI(msg.index, msg.count, msg.nodeText);
            break;

        case 'replace-success':
            feedbackMessage.textContent = `${msg.count} ${msg.count > 1 ? 'replaced items' : 'replaced item'}.`;
            feedbackContainer.classList.remove('hidden');
            
            if (msg.allReplaced) {
                resetFinderUI();
            } else if (msg.updatedNode) {
                updateFinderUI(msg.updatedNode.index, msg.updatedNode.count, msg.updatedNode.nodeText);
            }
            break;
            
        case 'all-replace-success':
            resetFinderUI();
            break;

        case 'hide-undo':
             hideFeedback();
             break;

        case 'undo-complete':
            hideFeedback();
            triggerSearch();
            break;
    }
  };

  // --- LÓGICA DO PAINEL DE FORMATAÇÃO ---

  formatterToggle.addEventListener('click', () => {
    formatterPanel.classList.toggle('hidden');
  });

  formatterTokens.addEventListener('click', (event) => {
    if (event.target.classList.contains('token')) {
      const token = event.target.dataset.token;
      const input = formatRuleInput;

      // Adiciona um espaço se o input não estiver vazio
      const prefix = input.value ? input.value + ' ' : '';

      if (token === '{text=}') {
        input.value = prefix + '{text=SUA_STRING}';
      } else {
        input.value = prefix + token;
      }
      updateApplyButtonState(); // Ativa o botão Apply ao adicionar um token
    }
  });

  clearFormatRuleBtn.addEventListener('click', () => {
    formatRuleInput.value = '';
    activeFormatRule = ''; // Limpa a regra ativa
    formatterToggle.classList.remove('active'); // Desativa a cor do ícone
    updateApplyButtonState(); // Atualiza o estado do botão Apply
  });

  undoButton.onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'undo-last-change' } }, '*');
  };

  findInput.addEventListener('input', () => {
      hideFeedback();
      triggerSearch();
  });
  replaceInput.addEventListener('input', () => {
      hideFeedback();
      updatePreview();
      updateButtonStates();
  });

  applyFormatRuleBtn.addEventListener('click', () => {
    activeFormatRule = formatRuleInput.value.trim();

    if (activeFormatRule) {
      formatterToggle.classList.add('active'); // Ativa a cor do ícone
    } else {
      formatterToggle.classList.remove('active'); // Remove a cor se a regra estiver vazia
    }

    formatterPanel.classList.add('hidden'); // Fecha o painel
    updateApplyButtonState(); // Ativa o botão Apply ao aplicar a regra
  });
  
  textListContainer.addEventListener('input', (event) => {
    if (event.target.tagName === 'INPUT') {
      const input = event.target;
      const resetIcon = input.nextElementSibling;
      
      if (input.value !== input.dataset.originalText) {
        resetIcon.classList.add('visible');
      } else {
        resetIcon.classList.remove('visible');
      }
      updateApplyButtonState(); // Atualiza o estado do botão Apply
    }
  });

  textListContainer.addEventListener('click', (event) => {
    const resetIcon = event.target.closest('.reset-icon');
    if (resetIcon) {
      const wrapper = resetIcon.parentElement;
      const input = wrapper.querySelector('input');
      
      input.value = input.dataset.originalText;
      resetIcon.classList.remove('visible');
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }

    const lockIcon = event.target.closest('.lock-icon');
    if (lockIcon) {
      const nodeIdToLock = lockIcon.dataset.nodeId;
      if (lockedNodeId === nodeIdToLock) {
        lockedNodeId = null; // Desativa o lock
      } else {
        lockedNodeId = nodeIdToLock; // Ativa o lock
      }
      renderContent(lastReceivedData); // Re-renderiza para atualizar os estados visuais
      updateApplyButtonState(); // Atualiza o estado do botão Apply
    }
  });

  function applyFormatRule(rule, originalText, index, totalItems) {
    if (!rule) return originalText; // Retorna o original se não houver regra

    let result = rule;

    // 1. Substitui o texto atual
    result = result.replace(/\{current_text\}/g, originalText);

    // 2. Substitui o número crescente (base 1)
    result = result.replace(/\{1-9\}/g, String(index + 1));

    // 3. Substitui o número decrescente
    result = result.replace(/\{9-1\}/g, String(totalItems - index));

    // 4. Substitui o texto fixo (ex: {text=Hello World})
    result = result.replace(/\{text=(.*?)\}/g, (match, p1) => p1);

    return result.trim();
  }

  function updateApplyButtonState() {
    let hasManualChanges = false;
    const inputs = textListContainer.querySelectorAll('input[type="text"]');
    for (const input of inputs) {
      if (input.value !== input.dataset.originalText) {
        hasManualChanges = true;
        break;
      }
    }
    // O botão Apply fica ativo se houver formatação ativa OU se houver mudanças manuais OU se houver um item travado
    applyButton.disabled = !(activeFormatRule || hasManualChanges || lockedNodeId);
  }

  applyButton.onclick = () => {
    const inputs = textListContainer.querySelectorAll('input[type="text"]');
    const changes = [];
    const formatRule = activeFormatRule;
    let lockedTextContent = '';

    if (lockedNodeId) {
      const lockedInput = document.querySelector(`input[data-node-id="${lockedNodeId}"]`);
      if (lockedInput) {
        lockedTextContent = lockedInput.value;
      }
    }

    inputs.forEach((input, index) => {
      const nodeId = input.dataset.nodeId;
      const originalText = input.dataset.originalText;
      let newText = input.value; // Começa com o valor atual do input (manual ou original)

      if (lockedNodeId && nodeId !== lockedNodeId) {
        // Se há um item travado e este não é o item travado, usa o conteúdo do item travado
        newText = lockedTextContent;
      } else if (formatRule) {
        // Se há uma regra de formatação, aplica-a sobre o texto original
        const totalItems = inputs.length;
        const formattedText = applyFormatRule(formatRule, originalText, index, totalItems);
        
        // Se houver edição manual E formatação, a formatação é aplicada sobre o texto original,
        // e a edição manual é considerada apenas se não houver formatação.
        // Para aplicar ambas, precisamos de uma lógica mais complexa, por exemplo:
        // Se o input foi editado manualmente, a edição manual tem prioridade,
        // a menos que a formatação seja para "replicar" (como o lock).
        // Para simplificar, vamos aplicar a formatação sobre o texto original,
        // e se o usuário editou manualmente, a edição manual prevalece,
        // a menos que o lock esteja ativo.
        if (input.value !== originalText && !lockedNodeId) {
            // Se houve edição manual e não há lock, a edição manual prevalece
            newText = input.value;
        } else {
            newText = formattedText;
        }
      }

      // Adiciona a mudança apenas se o novo texto for diferente do original
      if (newText !== originalText) {
        if (currentMode === 'texts') {
          changes.push({ nodeId: nodeId, newText: newText });
        } else {
          changes.push({ nodeId: nodeId, newName: newText });
        }
      }
    });

    if (changes.length > 0) {
      const messageType = currentMode === 'texts' ? 
        'apply-changes' : 'apply-frame-name-changes';
      parent.postMessage({ pluginMessage: { type: messageType, data: changes } }, '*');
      
      // Feedback visual para o Lock Text
      if (lockedNodeId) {
        figma.notify(`"${lockedTextContent}" replicado para os itens selecionados!`);
      }
    }

    // Atualiza o 'originalText' para o novo valor aplicado e remove o reset icon
    inputs.forEach(input => {
      const change = changes.find(c => c.nodeId === input.dataset.nodeId);
      if (change) {
          const newValue = currentMode === 'texts' ? change.newText : change.newName;
          input.dataset.originalText = newValue;
          input.value = newValue;
      } else if (lockedNodeId && input.dataset.nodeId !== lockedNodeId) {
          // Se o item não foi alterado manualmente, mas foi afetado pelo lock
          input.dataset.originalText = lockedTextContent;
          input.value = lockedTextContent;
      }

      const resetIcon = input.nextElementSibling;
      if (resetIcon) {
        resetIcon.classList.remove('visible');
      }
    });

    // Esconde o painel de formatação e desativa o toggle se não houver regra ativa
    if (!activeFormatRule) {
      formatterPanel.classList.add('hidden');
      formatterToggle.classList.remove('active');
    }
    
    // Desativa o botão Apply após a aplicação
    updateApplyButtonState();
  };

  findInput.addEventListener('input', triggerSearch);
  replaceInput.addEventListener('input', () => {
    updatePreview();
    updateButtonStates();
  });
  
  caseSensitiveToggle.onclick = () => {
    isCaseSensitive = !isCaseSensitive;
    caseSensitiveToggle.classList.toggle('active', isCaseSensitive);
    triggerSearch();
  };

  finderNext.onclick = () => { parent.postMessage({ pluginMessage: { type: 'navigate', direction: 'next' } }, '*'); };
  finderPrev.onclick = () => { parent.postMessage({ pluginMessage: { type: 'navigate', direction: 'prev' } }, '*'); };

  replaceSingleBtn.onclick = () => {
    parent.postMessage({ 
      pluginMessage: { 
        type: 'replace-single',
        findText: findInput.value,
        replaceText: replaceInput.value,
        isCaseSensitive: isCaseSensitive
      } 
    }, '*');
  };

  replaceAllBtn.onclick = () => {
    parent.postMessage({ 
      pluginMessage: { 
        type: 'replace-all',
        findText: findInput.value,
        replaceText: replaceInput.value,
        isCaseSensitive: isCaseSensitive
      } 
    }, '*');
  };

  tabFinder.addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.remove('hidden');
    applyButton.classList.add('hidden'); // Esconde o botão Apply na aba Finder
  });

  document.getElementById('tab-texts').addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.add('hidden');
    applyButton.classList.remove('hidden');
    updateApplyButtonState(); // Garante que o botão Apply seja atualizado ao mudar de aba
  });

  document.getElementById('tab-frames').addEventListener('click', () => {
    footer.classList.remove('hidden');
    finderActions.classList.add('hidden');
    applyButton.classList.remove('hidden');
    updateApplyButtonState(); // Garante que o botão Apply seja atualizado ao mudar de aba
  });

  // Inicializa o estado do botão Apply
  updateButtonStates();
  updateApplyButtonState();
</script>
