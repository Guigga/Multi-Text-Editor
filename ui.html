<!-- ui.html -->
<!-- Reescrito e simplificado: mantém todas as funcionalidades, melhora estabilidade e clareza -->
<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Figma Text Manager</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
  * { box-sizing: border-box; }
  body {
    margin: 0; padding: 0;
    font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color: #2D2D2D; background: #EFEFEF; height: 100vh; overflow: hidden;
  }
  .plugin-wrapper { display:flex; flex-direction:column; height:100vh; }
  .tabs-container { background:#fff; border-bottom:1px solid #AEAEAE; padding:12px 16px; flex-shrink:0; }
  .tabs-wrapper { display:flex; justify-content:space-between; align-items:center; }
  .tabs { display:flex; gap:12px; }
  .tab { cursor:pointer; font-size:14px; color:#AEAEAE; padding:6px 8px; border-radius:6px; }
  .tab.active { color:#2D2D2D; font-weight:600; background:transparent; }
  #formatter-toggle { background:none; border:none; cursor:pointer; padding:6px; border-radius:6px; opacity:0.6; }
  #formatter-toggle.active { background:#eaf6ff; opacity:1; }
  .content-area { padding:12px; overflow:auto; flex:1; }
  .container { text-align:center; color:#5F5F5F; padding-top:36px; }
  .frame-group { margin-bottom:14px; }
  .frame-title { font-size:13px; font-weight:600; margin-bottom:8px; color:#2D2D2D; }
  .input-wrapper { display:flex; align-items:center; gap:8px; margin-bottom:8px; position:relative; }
  .input-wrapper.locked input { background:#f0f9ff; border-color:#0ea5e9; }
  .lock-icon { width:20px; height:20px; display:flex; align-items:center; justify-content:center; cursor:pointer; opacity:0.8; }
  .lock-icon.active { color:#0284c7; opacity:1; }
  input[type="text"] { flex:1; padding:10px 12px; border:1px solid #AEAEAE; border-radius:8px; background:#fff; font-size:14px; color:#2D2D2D; }
  input[type="text"]:disabled { background:#F5F5F5; color:#AEAEAE; cursor:not-allowed; }
  .reset-icon { width:18px; height:18px; cursor:pointer; opacity:0.7; visibility:hidden; fill: none;}
  .reset-icon.visible { visibility:visible; opacity:1; }
  .footer { padding:12px 16px; background:#fff; border-top:0.5px solid #AEAEAE; display:flex; justify-content: space-between; gap:8px; flex-shrink:0; }
  .footer .creator {font-size: 12px; color: #6f7687;user-select: none; padding-top:18px; }
  button { border:none; border-radius:6px; padding:10px 14px; font-weight:600; cursor:pointer; }
  #apply { background:#2D2D2D; color:#fff; }
  #apply:disabled { background:#DFDFDF; color:#5F5F5F; cursor:not-allowed; }
  .finder-section { margin-bottom:12px; }
  .finder-title { font-weight:600; font-size:13px; margin-bottom:6px; color:#2D2D2D; display:flex; justify-content:space-between; align-items:center; }
  .finder-nav { display:flex; gap:6px; align-items:center; }
  .finder-nav button { padding:6px 8px; border-radius:6px; background:transparent; border:1px solid transparent; cursor:pointer; }
  .finder-nav button:disabled { opacity:0.4; cursor:not-allowed; }
  #preview-text { width:100%; height:96px; resize:none; border:1px solid #AEAEAE; border-radius:8px; padding:10px; background:#F5F5F5; color:#5F5F5F; }
  .feedback { display:flex; justify-content:space-between; gap:8px; align-items:center; background:#e0f2fe; color:#0c4a6e; padding:8px 12px; border-radius:6px; font-size:13px; margin-top:8px; }
  .hidden { display:none !important; }
  .formatter-panel { position:absolute; left:16px; right:16px; top:56px; background:#fff; border:1px solid #AEAEAE; border-radius:8px; padding:12px; z-index:10; box-shadow:0 6px 20px rgba(0,0,0,0.08); }
  .formatter-tokens { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .token { background:#e9e9e9; padding:6px 8px; border-radius:6px; cursor:pointer; font-weight:500; }
  .kbd { background:#F5F5F5; border:1px solid #CCC; border-radius:4px; padding:2px 6px; font-family:monospace; font-size:12px; }
  #finder-actions {display: flex; gap: 8px;}
  .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.8); z-index: 100; display: flex; align-items: center; justify-content: center; text-align: center; color: #2D2D2D; font-size: 14px; backdrop-filter: blur(2px); }
  #case-sensitive-toggle { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); padding: 6px 8px; border-radius: 6px;   border: 1px solid transparent; background: #fff; cursor: pointer; }
  #case-sensitive-toggle.active { background: #e0f2fe; border-color: #0ea5e9; }
</style>
</head>
<body>
<div class="plugin-wrapper">
  <div id="loading-overlay" class="loading-overlay hidden">
    <p id="loading-message">Processing...</p>
  </div>

  <div class="tabs-container">
    <div class="tabs-wrapper">
      <div class="tabs">
        <div class="tab active" id="tab-texts">Texts</div>
        <div class="tab" id="tab-frames">Frames</div>
        <div class="tab" id="tab-finder">Finder</div>
      </div>
      <button id="formatter-toggle" title="Open/Close Formatter">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M3 5h18M7 12h10M3 19h18" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
    </div>
  </div>

  <div id="formatter-panel" class="formatter-panel hidden" aria-hidden="true">
    <div class="finder-title">Create Formatting Rule</div>
    <div style="margin-top:8px;">
      <input id="format-rule-input" type="text" placeholder="Ex: {current_text} - {1-9}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #AEAEAE;">
      <div class="formatter-tokens">
        <div class="token" data-token="{current_text}">Current text</div>
        <div class="token" data-token="{1-9}">1-9</div>
        <div class="token" data-token="{9-1}">9-1</div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:10px;">
        <button id="clear-format-rule" style="background:none; border:none; color:#5F5F5F;">Clear</button>
        <button id="apply-format-rule" style="background:#2D2D2D; color:#fff;">Apply rule</button>
      </div>
    </div>
  </div>

  <div class="content-area">
    <div id="empty-state" class="container">
      <p style="font-size:14px;">No text selected</p>
      <p style="font-size:12px;">Select by pressing <span class="kbd">Ctrl</span> + <span class="kbd">Shift</span></p>
    </div>

    <div id="text-list-container" class="hidden" aria-live="polite"></div>

    <div id="finder-container" class="hidden">
      <div class="finder-section">
        <div class="finder-title">
          <span>Finder</span>
          <div class="finder-nav">
            <button id="finder-prev" disabled>&lt;</button>
            <span id="finder-counter">0/0</span>
            <button id="finder-next" disabled>&gt;</button>
          </div>
        </div>
        <div style="position:relative;">
          <input id="find-input" type="text" placeholder="What are you looking for?" style="width:100%; padding:10px 48px 10px 12px; border-radius:8px; border:1px solid #AEAEAE;">
          <button id="case-sensitive-toggle">Aa</button>
        </div>
      </div>

      <div class="finder-section">
        <div class="finder-title">Replace</div>
        <input id="replace-input" type="text" placeholder="Replace with..." style="width:100%; padding:10px; border-radius:8px; border:1px solid #AEAEAE;">
      </div>

      <div class="finder-section">
        <div class="finder-title">Preview</div>
        <textarea id="preview-text" readonly></textarea>
      </div>
    </div>

    <div id="feedback-container" class="hidden feedback">
      <span id="feedback-message"></span>
      <div style="display:flex; gap:8px;">
        <button id="undo-button" style="background:none; border:1px solid #0ea5e9; color:#0284c7; padding:6px 10px; border-radius:6px;">Undo</button>
      </div>
    </div>
  </div>

  <div class="footer hidden" id="footer">
    <div class="creator">Created by: Guigga</div>
    <div id="finder-actions" class="hidden";>
      <button id="replace-single" disabled style="background:#fff; border:1px solid #AEAEAE; color:#2D2D2D;">Replace</button>
      <button id="replace-all" disabled style="background:#2D2D2D; color:#fff;">Replace All</button>
    </div>
    <button id="apply" disabled>Apply →</button>
  </div>
</div>

<!-- SVGs -->
<svg style="display:none;">
  <symbol id="lock" viewBox="0 0 24 24"><path d="M5 11V7a7 7 0 0114 0v4" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><rect x="3" y="11" width="18" height="10" rx="2" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></symbol>
  <symbol id="unlock" viewBox="0 0 24 24"><path d="M7 11V7a5 5 0 019.9-1" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><rect x="3" y="11" width="18" height="10" rx="2" stroke="#2D2D2D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></symbol>
  <symbol id="reset-icon" viewBox="0 0 16 15"><path d="M3.7 1.5L1 3.75M1 3.75L3.7 6.375M1 3.75H9.94C12.62 3.75 14.89 5.8575 14.996 8.4375C15.1067 11.1637 12.77 13.5 9.942 13.5H3.33" stroke="#5F5F5F" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></symbol>
</svg>

<script>
  // State
  let currentMode = 'texts'; // texts | frames | finder
  let lastReceivedData = null;
  let activeFormatRule = '';
  let lockedNodeId = null;
  let isCaseSensitive = false;
  let currentOriginalNodeText = '';
  let searchResultsCount = 0;

  // Elements
  const tabTexts = document.getElementById('tab-texts');
  const tabFrames = document.getElementById('tab-frames');
  const tabFinder = document.getElementById('tab-finder');
  const textListContainer = document.getElementById('text-list-container');
  const emptyState = document.getElementById('empty-state');
  const footer = document.getElementById('footer');
  const applyBtn = document.getElementById('apply');
  const finderContainer = document.getElementById('finder-container');
  const finderPrev = document.getElementById('finder-prev');
  const finderNext = document.getElementById('finder-next');
  const finderCounter = document.getElementById('finder-counter');
  const findInput = document.getElementById('find-input');
  const replaceInput = document.getElementById('replace-input');
  const previewText = document.getElementById('preview-text');
  const replaceSingleBtn = document.getElementById('replace-single');
  const replaceAllBtn = document.getElementById('replace-all');
  const caseToggle = document.getElementById('case-sensitive-toggle');
  const feedbackContainer = document.getElementById('feedback-container');
  const feedbackMessage = document.getElementById('feedback-message');
  const undoButton = document.getElementById('undo-button');
  const finderActions = document.getElementById('finder-actions');
  const formatterToggle = document.getElementById('formatter-toggle');
  const formatterPanel = document.getElementById('formatter-panel');
  const formatRuleInput = document.getElementById('format-rule-input');
  const formatterTokens = document.querySelectorAll('.token');
  const clearFormatRuleBtn = document.getElementById('clear-format-rule');
  const applyFormatRuleBtn = document.getElementById('apply-format-rule');
  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingMessage = document.getElementById('loading-message');

  // Helpers
  function setMode(mode) {
    currentMode = mode;
    tabTexts.classList.toggle('active', mode === 'texts');
    tabFrames.classList.toggle('active', mode === 'frames');
    tabFinder.classList.toggle('active', mode === 'finder');

    const isFinder = mode === 'finder';
    finderContainer.classList.toggle('hidden', !isFinder);
    textListContainer.classList.toggle('hidden', isFinder);
    // --> LINHA ADICIONADA: Esconde a mensagem de estado vazio quando estiver no Finder.
    if (isFinder) emptyState.classList.add('hidden');
    
    footer.classList.remove('hidden');
    finderActions.classList.toggle('hidden', !isFinder);
    applyBtn.classList.toggle('hidden', isFinder);
    if (!isFinder && lastReceivedData) renderContent(lastReceivedData);
    updateApplyButtonState();
  }

  tabTexts.onclick = () => setMode('texts');
  tabFrames.onclick = () => setMode('frames');
  tabFinder.onclick = () => setMode('finder');

  // render methods
  function renderContent(data) {
    lastReceivedData = data;
    if (currentMode === 'texts') {
      renderTextView(data.textData || {});
    } else if (currentMode === 'frames') {
      renderFrameView(data.frameData || []);
    }
    updateApplyButtonState();
  }

  function createLockIcon(nodeId, active) {
    const div = document.createElement('div');
    div.className = 'lock-icon' + (active ? ' active' : '');
    div.dataset.nodeId = nodeId;
    div.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none">${active ? '<use href="#lock"/>' : '<use href="#unlock"/>'}</svg>`;
    return div;
  }

  function renderTextView(textData) {
    const frameIds = Object.keys(textData || {});
    if (frameIds.length === 0) {
      showEmptyState('No text selected');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
      return;
    }
    emptyState.classList.add('hidden');
    textListContainer.classList.remove('hidden');
    footer.classList.remove('hidden');
    textListContainer.innerHTML = '';
    for (const frameId of frameIds) {
      const frame = textData[frameId];
      const group = document.createElement('div');
      group.className = 'frame-group';
      const title = document.createElement('div');
      title.className = 'frame-title';
      title.textContent = frame.frameName;
      group.appendChild(title);

      for (const node of frame.textNodes) {
        const wrapper = document.createElement('div');
        wrapper.className = 'input-wrapper';
        if (lockedNodeId === node.nodeId) wrapper.classList.add('locked');

        const lock = createLockIcon(node.nodeId, lockedNodeId === node.nodeId);
        lock.title = 'Lock this node as source';
        const input = document.createElement('input');
        input.type = 'text';
        input.value = node.characters;
        input.dataset.nodeId = node.nodeId;
        input.dataset.originalText = node.characters;

        if (lockedNodeId && lockedNodeId !== node.nodeId) input.disabled = true;

        const reset = document.createElement('div'); // Usamos um div como container
        reset.className = 'reset-icon' + (input.value !== input.dataset.originalText ? ' visible' : '');
        reset.innerHTML = `<svg width="16" height="15"><use href="#reset-icon"/></svg>`;

        wrapper.appendChild(lock);
        wrapper.appendChild(input);
        wrapper.appendChild(reset);
        group.appendChild(wrapper);
      }
      textListContainer.appendChild(group);
    }
  }
  

  function renderFrameView(frameData) {
    if (!frameData || frameData.length === 0) {
      showEmptyState('No frames selected');
      textListContainer.classList.add('hidden');
      footer.classList.add('hidden');
      return;
    }
    emptyState.classList.add('hidden');
    textListContainer.classList.remove('hidden');
    footer.classList.remove('hidden');
    textListContainer.innerHTML = '';
    const group = document.createElement('div'); group.className = 'frame-group';
    for (const frame of frameData) {
      const wrapper = document.createElement('div'); wrapper.className = 'input-wrapper';
      if (lockedNodeId === frame.nodeId) wrapper.classList.add('locked');

      const lock = createLockIcon(frame.nodeId, lockedNodeId === frame.nodeId);
      const input = document.createElement('input'); input.type = 'text';
      input.value = frame.name; input.dataset.nodeId = frame.nodeId; input.dataset.originalText = frame.name;
      if (lockedNodeId && lockedNodeId !== frame.nodeId) input.disabled = true;

      const reset = document.createElement('div');
      reset.className = 'reset-icon' + (input.value !== input.dataset.originalText ? ' visible' : '');
      reset.innerHTML = `<svg width="16" height="15"><use href="#reset-icon"/></svg>`;

      wrapper.appendChild(lock); wrapper.appendChild(input); wrapper.appendChild(reset);
      group.appendChild(wrapper);
    }
    textListContainer.appendChild(group);
  }

  function showEmptyState(message) {
    if (currentMode === 'finder') return; // Finder nunca mostra empty state
    emptyState.querySelector('p:first-child').textContent = message;
    emptyState.classList.remove('hidden');
  }

  // Finder helpers
  function updateFinderUI(index, count, nodeText = '') {
    searchResultsCount = count;
    currentOriginalNodeText = nodeText || '';
    const has = count > 0;
    finderCounter.textContent = `${has ? index + 1 : 0}/${count}`;
    finderPrev.disabled = !has; finderNext.disabled = !has;
    previewText.value = currentOriginalNodeText;
    updateFinderButtons();
  }
  function updateFinderButtons() {
    const hasResults = searchResultsCount > 0;
    const hasReplace = replaceInput.value.trim() !== '';
    replaceSingleBtn.disabled = !(hasResults && hasReplace);
    replaceAllBtn.disabled = !(hasResults && hasReplace);
  }

  // messaging
  function postToPlugin(obj) { parent.postMessage({ pluginMessage: obj }, '*'); }

  // events
  window.onmessage = (evt) => {
    const msg = evt.data.pluginMessage;
    if (!msg) return;
    // hide feedback except for replace-success
    if (msg.type !== 'replace-success' && msg.type !== 'apply-success') {
      feedbackContainer.classList.add('hidden');
    }

    switch (msg.type) {

      case 'show-loading':
        loadingMessage.textContent = msg.message || 'Processing...';
        loadingOverlay.classList.remove('hidden');
        // Opcional: desabilitar outros botões para evitar cliques
        replaceAllBtn.disabled = true;
        replaceSingleBtn.disabled = true;
        break;

      case 'hide-loading':
        loadingOverlay.classList.add('hidden');
        // Reabilita os botões (a função updateFinderButtons já faz isso)
        updateFinderButtons();
        break;

      case 'selectionChange':
        // preserva lock apenas se o nó ainda existir na nova seleção
        if (lockedNodeId) {
          const stillExistsInText = msg.textData && Object.keys(msg.textData).some(frameId => msg.textData[frameId].textNodes.some(n => n.nodeId === lockedNodeId));
          const stillExistsInFrames = msg.frameData && msg.frameData.some(n => n.nodeId === lockedNodeId);
          if (!(stillExistsInText || stillExistsInFrames)) lockedNodeId = null;
        }
        lastReceivedData = msg;
        renderContent(msg);
        break;

      case 'search-result':
        updateFinderUI(-1, 0, '');
        break;

      case 'navigation-update':
        updateFinderUI(msg.index, msg.count, msg.nodeText || '');
        break;

      case 'replace-success':
        feedbackMessage.textContent = `${msg.count} ${msg.count > 1 ? 'replaced items' : 'replaced item'}.`;
        feedbackContainer.classList.remove('hidden');
        if (msg.allReplaced) {
          // limpa finder UI
          findInput.value = '';
          replaceInput.value = '';
          updateFinderUI(-1, 0, '');
        } else if (msg.updatedNode) {
          updateFinderUI(msg.updatedNode.index, msg.updatedNode.count, msg.updatedNode.nodeText);
        }
        break;

      case 'apply-success':
        feedbackMessage.textContent = `${msg.count} ${msg.count > 1 ? 'items updated' : 'item updated'}.`;
        feedbackContainer.classList.remove('hidden');
        break;

      case 'undo-complete':
        feedbackContainer.classList.add('hidden');
        // re-trigger search so preview updates
        postToPlugin({ type: 'find-text', query: findInput.value, isCaseSensitive: isCaseSensitive });
        break;

      case 'plugin-error':
        alert('Plugin error: ' + (msg.message || 'unknown'));
        break;
    }
  };

  // interactions
  // find input
  findInput.addEventListener('input', () => {
    postToPlugin({ type: 'find-text', query: findInput.value, isCaseSensitive: isCaseSensitive });
  });
  caseToggle.addEventListener('click', () => {
    isCaseSensitive = !isCaseSensitive;
    caseToggle.classList.toggle('active', isCaseSensitive);
    postToPlugin({ type: 'find-text', query: findInput.value, isCaseSensitive: isCaseSensitive });
  });

  finderNext.addEventListener('click', () => postToPlugin({ type: 'navigate', direction: 'next' }));
  finderPrev.addEventListener('click', () => postToPlugin({ type: 'navigate', direction: 'prev' }));

  replaceSingleBtn.addEventListener('click', () => {
    postToPlugin({ type: 'replace-single', findText: findInput.value, replaceText: replaceInput.value, isCaseSensitive });
  });
  replaceAllBtn.addEventListener('click', () => {
    postToPlugin({ type: 'replace-all', findText: findInput.value, replaceText: replaceInput.value, isCaseSensitive });
  });

  replaceInput.addEventListener('input', () => {
    previewText.value = currentOriginalNodeText.replace(new RegExp(escapeForRegex(findInput.value || ''), isCaseSensitive ? '' : 'i'), replaceInput.value || '');
    updateFinderButtons();
  });

  function escapeForRegex(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // undo
  undoButton.addEventListener('click', () => {
    postToPlugin({ type: 'undo-last-change' });
  });

  // formatter toggle
  formatterToggle.addEventListener('click', () => {
    formatterPanel.classList.toggle('hidden');
    formatterToggle.classList.toggle('active', !formatterPanel.classList.contains('hidden'));
  });
  formatterTokens.forEach(token => {
    token.addEventListener('click', () => {
      const t = token.dataset.token;
      const cur = formatRuleInput.value;
      formatRuleInput.value = cur ? cur + ' ' + t : t;
    });
  });
  clearFormatRuleBtn.addEventListener('click', () => {
    formatRuleInput.value = '';
    activeFormatRule = '';
    formatterToggle.classList.remove('active');
    updateApplyButtonState();
  });
  applyFormatRuleBtn.addEventListener('click', () => {
    activeFormatRule = formatRuleInput.value.trim();
    if (activeFormatRule) formatterToggle.classList.add('active');
    else formatterToggle.classList.remove('active');
    formatterPanel.classList.add('hidden');
    updateApplyButtonState();
  });

  applyBtn.addEventListener('click', () => {
    const inputs = Array.from(textListContainer.querySelectorAll('input[type="text"]'));
    const changes = [];
    const formatRule = activeFormatRule;
    let lockedTextContent = '';

    if (lockedNodeId) {
      const lockedInput = document.querySelector(`input[data-node-id="${lockedNodeId}"]`);
      if (lockedInput) lockedTextContent = lockedInput.value;
    }

    inputs.forEach((input, idx) => {
      const nodeId = input.dataset.nodeId;
      const original = input.dataset.originalText;
      let newText = input.value;

      if (lockedNodeId && nodeId !== lockedNodeId) {
        newText = lockedTextContent;
      } else if (formatRule) {
        const total = inputs.length;
        const formatted = applyFormatRule(formatRule, original, idx, total);
        if (input.value !== original && !lockedNodeId) {
          newText = input.value;
        } else {
          newText = formatted;
        }
      }

      if (newText !== original) {
        if (currentMode === 'texts') changes.push({ nodeId, newText });
        else changes.push({ nodeId, newName: newText });
      }
    });

    if (lockedNodeId) {
      const already = changes.some(c => c.nodeId === lockedNodeId);
      if (!already) {
        const lockedInput2 = document.querySelector(`input[data-node-id="${lockedNodeId}"]`);
        if (lockedInput2) {
          const lockedVal2 = lockedInput2.value;
          if (currentMode === 'texts') {
            changes.push({ nodeId: lockedNodeId, newText: lockedVal2 });
          } else {
            changes.push({ nodeId: lockedNodeId, newName: lockedVal2 });
          }
        }
      }
    }

    if (changes.length === 0) return;
    const messageType = currentMode === 'texts' ? 'apply-changes' : 'apply-frame-name-changes';
    postToPlugin({ type: messageType, data: changes });

    if (lastReceivedData) {
      changes.forEach(c => {
        const val = currentMode === 'texts' ? c.newText : c.newName;
        if (currentMode === 'texts') {
          for (const frameId in lastReceivedData.textData) {
            const n = lastReceivedData.textData[frameId].textNodes.find(x => x.nodeId === c.nodeId);
            if (n) n.characters = val;
          }
        } else {
          const f = lastReceivedData.frameData.find(x => x.nodeId === c.nodeId);
          if (f) f.name = val;
        }
      });
    }

    lockedNodeId = null;
    renderContent(lastReceivedData);
    if (!activeFormatRule) {
      formatterPanel.classList.add('hidden');
      formatterToggle.classList.remove('active');
    }
  });

  // Delegation for reset and lock clicks and input edits
  textListContainer.addEventListener('click', (event) => {
    const reset = event.target.closest('.reset-icon');
    if (reset) {
      const wrapper = reset.closest('.input-wrapper');
      const input = wrapper.querySelector('input');
      input.value = input.dataset.originalText;
      reset.classList.remove('visible');
      input.dispatchEvent(new Event('input', { bubbles: true }));
      updateApplyButtonState();
      return;
    }

    const lock = event.target.closest('.lock-icon');
    if (lock) {
      const nodeId = lock.dataset.nodeId;
      const input = lock.parentElement.querySelector('input');
      const currentValue = input.value;

      // atualiza lastReceivedData imediatamente para preservar edição
      if (lastReceivedData) {
        if (currentMode === 'texts') {
          for (const frameId in lastReceivedData.textData) {
            const n = lastReceivedData.textData[frameId].textNodes.find(x => x.nodeId === nodeId);
            if (n) { n.characters = currentValue; break; }
          }
        } else {
          const ff = lastReceivedData.frameData.find(x => x.nodeId === nodeId);
          if (ff) ff.name = currentValue;
        }
      }

      if (lockedNodeId === nodeId) lockedNodeId = null;
      else lockedNodeId = nodeId;
      renderContent(lastReceivedData);
      updateApplyButtonState();
      return;
    }
  });

  // handle input changes visibility of reset
  textListContainer.addEventListener('input', (event) => {
    const input = event.target;
    if (input && input.tagName === 'INPUT') {
      const reset = input.parentElement.querySelector('.reset-icon');
      if (input.value !== input.dataset.originalText) reset.classList.add('visible');
      else reset.classList.remove('visible');
      updateApplyButtonState();
    }
  });

  function applyFormatRule(rule, original, index, total) {
    if (!rule) return original;
    let res = rule;
    res = res.replace(/\{current_text\}/g, original);
    res = res.replace(/\{1-9\}/g, String(index + 1));
    res = res.replace(/\{9-1\}/g, String(total - index));
    res = res.replace(/\{text=(.*?)\}/g, (m, p1) => p1);
    return res.trim();
  }

  function updateApplyButtonState() {
    const inputs = Array.from(textListContainer.querySelectorAll('input[type="text"]'));
    const hasManual = inputs.some(i => i.value !== i.dataset.originalText);
    applyBtn.disabled = !(activeFormatRule || hasManual || !!lockedNodeId);
  }

  document.addEventListener('keydown', (e) => {
    if (currentMode === 'finder') return;

    // Se for Enter e não estiver em textarea
    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
      e.preventDefault();
      if (!applyBtn.disabled) {
        applyBtn.click();
      }
    }
  });

  updateFinderButtons();
  updateApplyButtonState();
</script>
</body>
</html>
